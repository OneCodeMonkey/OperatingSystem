# 操作系统原理

分五个部分分开讲：

1.进程

2.线程

3.CPU的任务调度

4.进程的同步

5.死锁。



## 进程

### 1.进程概念

### 2.进程的调度

### 3.进程控制

### 4.进程协作

### 5.进程通信



### 1.进程概念

#### 1.1 进程定义

进程是程序的具体执行。进程执行必须按照一定的顺序进行。

进程由四部分组成：

- Process Control Block
- 程序体
- 数据区
- 进程栈

![进程的组成](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/%E8%BF%9B%E7%A8%8B%E7%BB%84%E6%88%90.png?raw=true)



`进程`与 `程序` 的区别：

- 进程包括`程序` 和 `数据`两部分
- 进程有生命周期，有创建有销毁，是动态的概念。而`程序`是一个静态的概念，`程序`是相对长久的存在。
- 进程能创建其他进程，而程序不能去创建其他程序
- 进程能描述并发，而程序不能

#### 1.2 进程的状态

- 新建状态
- 运行状态
- 等待状态
- 就续状态
- 终止状态

![进程状态切换2.png](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A22.png?raw=true)



###### 进程状态切换图

![进程状态切换.png](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png?raw=true)



#### 1.3 进程控制块 （PCB, Process Control Block）

- Process state
  Program counter
  CPU registers
  CPU scheduling information
  Memory-management information
  Accounting information
  I/O status information

![PCB组成.png](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/PCB%E7%BB%84%E6%88%90.png?raw=true)



![进程运行与PCB的交互.png](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E4%B8%8EPCB%E7%9A%84%E4%BA%A4%E4%BA%92.png?raw=true)



###### PCB表

系统会把所有 PCB 记录组织存放在内存的固定区域，这个部分就是系统的 PCB 表。

分为两部分：链表， 索引表

PCB 表的大小决定了系统中最多可以同时存在的进程的个数。这个值反映了系统的**并发度**



![PCB链表队列.png](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/PCB%E8%A1%A8%E7%9A%84%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97.png?raw=true)



![PCB索引表示意.png](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/PCB%E8%A1%A8%E7%9A%84%E7%B4%A2%E5%BC%95%E8%A1%A8.png?raw=true)

###### 进程队列

![进程队列示意图.png](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/%E8%BF%9B%E7%A8%8B%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true)



- 就续队列是没有优先级的，先进先出
- 当事件 n 发生时，对应的队列移进就续队列。

### 2.进程的调度

#### 2.1 调度的类型

- 高级调度

也称为作业调度或宏观调度

高级调度的时间尺度通常是分钟，小时或天。

- 中级调度

涉及进程在内外存间的交换

从存储器资源管理的角度来看，把进程部分全部换出到外存上，可为当前运行进程的执行提供所需内存空间，将当前进程所需部分换入到内存。指令和数据必须在内存里才能被处理机直接访问。

- 低级调度

也称微观调度

从处理机资源分配角度来看，处理机需要经常选择就续进程或线程进入运行状态

低级调度的时间尺度通常都是毫秒级的

由于低级调度算法使用和频繁，要求在实现上尽可能高效， 下面会简单介绍下进程的微观调度的几种算法策略。

#### 2.2 调度的模式

- 非剥夺方式
  - 简单，
  - 开销小
  - 实时性差
- 剥夺方式
  - 优先级原则：
  - 时间片原则：

#### 2.3 调度算法。

前面说到，进程的执行一定是有顺序的。cpu 会指定当前队列的进程里哪一个先执行，哪一个靠后。这就涉及到调度。

调度的衡量指标有这么几种：

- CPU利用率（谁能让CPU利用率更大）
- 吞吐量（单位时间内能处理完的进程数量）
- 周转时间（整个执行完一个进程所需要花的时间）（注意，如果发生了抢占，还是会以开头到结尾的时间差作为周转时间，所以发生抢占时周转时间会变长）
- 等待时间（进程在 `就绪队列`里需要等待的时间）
- 响应时间（在分时操作系统下，一个进程从被装载到 cpu，到产生第一次响应。是第一次响应，不是第一次的成功返回）

根据这几种不同的衡量指标，cpu 的调度有五种对应的最优原则：

- 最大 CPU 利用率
- 最大吞吐量
- 最小周转时间
- 最小等待时间
- 最小响应时间

CPU中的进程的调度算法，主要有下面六种

- 先到先服务调度（First Common First Serve, FCFS）
- 最短作业优先调度（Shortes-Job-First, SJR）
- 优先级调度（Priority Scheduling）
- 轮转法调度（Round Robin， RR）
- 多级队列调度（multilevel queue-scheduling）
- 多级反馈队列调度（multilevel feedback queue scheduling）

##### 2.3.1 FCFS 先到先服务

看一组例子：

![先到先服务](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/FCFS_1.png?raw=true)



![先到先服务](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/FCFS_2.png?raw=true)



##### 2.3.2 SJF 最短作业优先调度

每次先执行所有就绪队列中，所需执行时间最短的进程。

这是一种贪心策略。同时最终从平均等待时间这个角度来衡量，SJF 算法的表现也是最优的。

分为抢占式和非抢占式，抢占式又叫 **最短剩余时间优先作业调度**

看一组例子：

![SJF 非抢占式](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/SJF_1.png?raw=true)



![SJF 抢占式](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/SJF_2%E6%8A%A2%E5%8D%A0%E5%BC%8F.png?raw=true)



##### 2.3.3 优先级调度

思想: 假设当前的就绪队列的每一个进程都被赋予了一个优先级数字（优先权），那么 cpu 调度程序（dispatcher）每次决定取哪个进程来执行的时候，都优先选择优先级数字最小的进程来执行（字越小，优先权越大）。

SJF 就是一种特殊的优先权调度（根据执行时间短，长来排优先级高，低）

具体操作系统是怎么分配优先级的策略较为复杂，后面有时间再补充

优先级调度会带来两个问题：

- 饥饿：有的进程一直处在优先级低的地方，一直得不到执行。
- 倒置：有的进程先到达队列，但却很晚才执行；有的进程是晚到的，却早于最早到的进程而执行。

具体怎么解决这里不作深入讲，后面再补充。

##### 2.3.4 RR 轮转法调度

思想：把 cpu 的执行，按照一个间隔分为一个时间片。然后为当前待执行的进程，每一个都分配一个时间片，轮换着执行。轮换的时候，进程执行的先后仍然按 FIFO 先到先执行的顺序。

看这个例子：

![RR 轮转法调度](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/RR-rotate.png?raw=true)



##### 2.3.5 多级队列调度

各个级别队列用各自的调度算法，外部来决定进程进入哪个优先级的队列。

与下面的多级反馈队列调度不同的是，进程在分配 CPU 执行以后不能再继续在不同优先级队列之间跳动。

![多级队列调度](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/multi-level-feedback-dispatch.png?raw=true)



##### 2.3.6 多级反馈队列调度

进程可以在不同队列间移动，根据不同级队列的反馈来切换进程该进入哪个队列去执行。

多级反馈队列需要这几个部分来完成：

- 队列的数量
- 不同队列各自的调度算法
- 用来确定进程何时可以升级到较高优先级队列的方法
- 用来确定进程何时可以降级到较低优先级队列的方法
- 用来确定进程在需要执行时，具体要进哪个队列的方法

示意图：

![多级反馈队列调度](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/multi-level-feedback-dispatch-2.png?raw=true)



### 3.进程控制

#### 操作系统的执行模式

处理器在处理与操作系统相关的程序，和用户的程序时，采用的执行模式是不同的。一般的处理器至少支持两种执行模式（**用户模式**和 **特权模式**）。某些特定的 cpu 指令只能在 处理器的 **特权模式**下才能执行，比如读取或改变程序状态字之类的控制寄存器的指令，原始的 I/O 指令，与内存管理相关的指令等等。并且有部分内存区域只能在 **特权模式**下才能访问。

- 用户模式：运行用户程序时，处理器的执行模式
- 特权模式：
  - 系统模式
  - 控制模式
  - 内核模式：

之所以要区分两种执行模式，是为了保护操作系统和重要的操作系统表（比如 PCB 表）不受用户程序的干扰。在内核模式下，软件可以完全控制 cpu 机器所有的执行指令，寄存器和内存。这种底层的控制对用户程序而言不需要可见。

###### 处理器怎么知道切换是用户模式还是特权模式呢？

在进程的结构中包含一个 **程序状态字**，这个变量存在一个指示执行模式的位上。该位会因外部事件的改变而变化。比如当用户调用一个操作系统服务或系统中断来触发系统例程的执行时，执行模式被置为内核模式。当系统服务执行完返回用户程序时，执行模式被置为用户模式。厂商设计 cpu 时按照这种思路会在处理器里做一个记录运行模式的处理器状态寄存器位。

###### 内核模式下能完成重要的底层功能，如下表：

- 进程管理
  - 进程的创建和终止
  - 进程的调度和分派
  - 进程切换
  - 进程同步和进程间通信的支持
  - 管理进程控制块
- 内存管理
  - 为进程分配地址空间
  - 交换内存
  - 页和段管理
- I/O 管理
  - 缓冲区buffer 管理
  - 为进程分配 I/O 通道和设备
- 支持功能
  - 中断处理
  - 记账
  - 监视

#### 操作系统的控制原语

什么是原语？

原语是操作系统和计算机网络下的专有词汇。原语是由若干条机器指令组成的，用于完成特定功能的一个过程。

原语的执行具有原子性，中途不允许被中断。

- 创建进程原语：create()
- 撤销进程原语：exit()
- 阻塞进程原语：block()
- 唤醒原语：wakeup()
- 挂起进程原语：suspend()
- 激活进程原语：active()

#### 进程创建

进程的创建有两种途径：

1.有操作系统模块统一创建

2.父进程来创建子进程

###### 能够触发进程创建的事件：

- 用户登录
- 作业调度
- 提供服务
- 应用请求

###### 进程创建的步骤：

1.在 PCB 表里面为进程赋值一个统一的进程标识符,并添加一个 PCB 表项。

2.为进程分配空间。这一步包含为进程体的各个元素来分配。首先操作系统要先算出用户的私有地址空间（进程的程序和数据）和用户栈一共需要多少空间。然后还要为 PCB 分配额外空间。这步既可以按照默认值来分配，也可以根据基于用户请求来分配。

比如 fork 时，父进程会把自己创建时所需的值作为创建子进程请求的参数传递给操作系统。子进程可以共享父进程地址空间也可以额外申请空间。

3.初始化 PCB。包括进程 ID，进程的父进程 ID，进程状态等。通常初始化进程会把进程状态设为 **就绪**或 **等待**，优先级默认为低优先级（除非显示声明高优先级）。

进程创建之初是不具备任何系统资源的（IO设备，文件），除非显示声明请求这些资源，或者共享父进程的资源。

4.设置相应链接。前面讲过操作系统从就绪队列里取进程来执行，把新创建的进程节点会被添加到就绪队列或等待队列的链表里。

5.额外操作。创建或扩充其他数据结构。例如操作系统可以为了记录记账信息或评估性能，为每个进程维护一个单独的记账文件。

#### 进程切换

###### 什么事件会触发进程切换？

1.系统中断。

系统中断又分为普通中断 和 **陷阱**。

普通中断一般是与当前正在运行进程无关的某种外部事件。比如时钟中断， I/O 中断，内存读取失败等等。

- 时钟中断：操作系统会判断当前运行进程的执行时间，是否超过允许的最大时间段（前面提到的**时间片**）,执行时间超过时间片会触发时中断，进程会被切到就绪态，下一个进程开始执行
- I/O中断：如果产生了 I/O 活动，并且 I/O 往往是多个进程在一起等待，假设此次 I/O 返回了结果，那么系统会把当前阻塞态的进程变为就绪态，这时候就会产生一个抉择。操作系统会决定当前运行的进程，和现在就绪队列里的进程哪个优先级最高，再决定是继续当前进程，还是换另一个优先级更高的进程来执行。
- 内存读取失败：处理器如果遇到一个内存中不存在的引用

2.陷阱是与当前运行进程有关的事件，与当前进程运行产生的错误或异常条件有关，比如尝试访问一个不存在的文件，未定义的变量等等。

3.最后一种是系统调用。系统调用是由操作系统在内核模式下完成某些功能时的一种过程调用。比如请求 I/O 操作（打开文件请求）就属于系统调用。

###### 模式切换

系统在用户模式和特权模式之间进行切换。比如当前进程运行时出现中断，处理器需要从用户模式切到内核模式，执行一些中断处理的特权指令来处理运行产生的错误。

注意中断可能导致模式切换，当模式切换后不一定产生进程切换。有可能切到内核模式执行完中断处理后返回用户模式，仍然继续执行当前进程。

###### 进程切换会做哪些操作？

上面提到了模式切换和进程切换。模式切换并不一定改变进程运行状态，当进程切换会改变进程状态。当前处于运行态，切换后可能变成多种状态（就绪态，阻塞状态，挂起状态，退出状态）。

> 挂起态。如果发生 I/O 操作，I/O 操作一般远远比 CPU 执行指令的耗时要大， CPU 不能浪费时间去等 I/O 执行完再继续执行当前进程，所以会把当前进程交换外存中暂存起来，等 I/O 返回了再变为就绪态准备执行。这种叫做 **就绪/挂起** 态

切换进程会产生上下文切换开销，具体切换进程步骤如下：

- 保存当前进程的上下文，包括程序计数器和其他寄存器
- 更新当前运行态进程的 PCB，包括变更进程状态（由运行态变为就绪态，阻塞态，挂起态，推出态等）
- 把该进程的 PCB 移到相应的队列（就绪队列或等待队列，或挂起）
- 选中下一个进程继续执行。
- 更新 PCB 记录，更改里面的进程状态信息。
- 更新内存管理的相关数据结构。
- 载入程序计数器和其他寄存器先前的值，将处理器的上下文恢复为所选进程上次退出运行态时的上下文。

切换进程会比模式切换产生更大的上下文切换开销。

#### 进程终止

进程执行完成，发送请求给操作系统要求终止它（exit）

会做两件事：

1.输出结果数据。

2.OS 回收分配给进程的所有资源（cpu，内存等）

###### 另一种方式，父进程终止子进程(abort())。几种情形会发生这种终止：

1.子进程的资源使用超出了父进程给其分配的量

2.子进程任务执行完，正常结束

3.父进程自己被终止。

> 操作系统不允许父进程终止后子进程仍继续存在。



###### 扩展：僵尸进程，孤儿进程

这两种进程在操作系统里都容易出现。如果一个系统的僵尸进程如果过多，会可能导致系统无法给新创建的正常进程分配进程号，从而无法创建新进程。

怎么产生的？当子进程退出时，如果父进程没有做回收操作，没有回收子进程的资源并更改其对应的 PCB 信息，那么这个进程就不受制约了，变成僵尸进程。这时需要主动 kill 掉僵尸进程，或者有些僵尸进程不能直接 kill就kill 它的父进程， 这样它就变成孤儿进程，孤儿进程会被 PID 为1 的系统 init 进程去回收。  

孤儿进程的产生：如果父进程被提前结束，并没有让它正常走结束流程，那么子进程就没有对应的父进程来处理控制它了。孤儿进程会被 PID 1 的系统 init 进程回收，不用特殊处理。

### 4.进程协作

#### 进程与进程间的联系

###### 相交关系：

多个并发进程在逻辑上有相互影响关系

###### 无关：

并发进程在逻辑上无任何联系。

作用关系又分为直接作用和间接作用：

1.直接作用：进程之间的相互联系是可控的，这种只发生在有相交关系的进程之间。比如进程的通信，进程的同步。

2.间接作用：进程之间要通过某种外部条件才能发生联系。是无意识地安排的。既可以发生在相交关系的进程之间，也可以发生在无关联的进程之间。比如进程之间的互斥。



#### 进程同步

完成同一任务的伙伴进程之间，因为在某些位置需要协调它们的工作次序而相互等待或相互传递信息，所产生的制约关系。

或者可以理解为并发的进程互相共享对方的私有资源而引起的**直接制约**关系。

比如：进程 A 通过写缓冲区向进程 B 提供数据，但缓冲区为空时，B 取不到所需数据从而处于阻塞状态，一旦进程A 开始往缓冲区写数据，则进程 B 被唤醒。如果缓冲区被写满，那么进程 A 因为无法继续写入也处于阻塞状态，当进程 B 把缓冲区数据取走后，进程 A 又被唤醒。

这里简单介绍下概念，后续会仔细讲进程同步的方式方法。

#### 互斥

进程之间由于竞争**临界资源**而引起的**间接制约**关系，称为互斥.

**临界资源**：临界资源表示只能被一个进程占用的资源。

之所以叫间接，是因为各个并发进程的速度受公有资源来制约，而不是受其他进程来直接制约。



### 5.进程通信

#### 通信的类型

分为低级通信和高级通信。

- 低级通信：只能传递状态和整数值
  - 传送的信息量小，效率低，每次通信传递的信息量固定。如果要传递较多信息则需要多次通信
  - 编程复杂不友好。由用户直接来实现通信的细节，编程复杂容易出错。
- 高级通信：能够传递任意数量的数据。

#### 高级通信方式

###### 高级通信的方式：

1.共享存储区：信号量

通过共享数据结构或共享存储区来进程间通信。

- 基于共享数据结构的通信。这种通信效率低，适合传递少量的数据
- 基于共享存储区的通信方式。能够传输大量数据。

2.消息传递系统 ：这种进程间通信方式是用的比较广泛的通信机制。

分为两种类型：

- 直接通信：比如**消息缓冲通信**的方式。
- 间接通信：如**“信箱“**通信方式。

![消息传递系统](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/process-communication_message_dellivery_method.png?raw=true)



3.管道：这是基于共享文件的方式实现的通信方式。以文件系统为基础，用文件做缓冲的传输介质。

管道通信是 UNIX 系统里最原始实现的 IPC 通信方式

![管道通信方式](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/process-communication_message_tunnel.png?raw=true)

管道通信示意图：



4.其他方式：

- 信号量
- Socket 方式的 IPC 通信
- Streams 方式的 IPC 通信（双工管道）



demo1: 进程创建。父进程和子进程的 PID 关系。

fork() 这个操作比较特殊，可以一次调用二次返回：

- 如果 fork 失败，则只有一个负数返回。

- 如果fork 成功，那么在父进程中，会返回一个正整数，这个正整数代表 fork出来的子进程的 PID；同时会在子进程中中返回一个整数 0。

fork() 操作创建进程失败通常有两种原因：

1. 系统的进程号不够用了。达到系统的进程数上限了。比如后台运行的僵尸进程数占用过多，
2. 可分配的内存不够用了。

> fork 出来的子进程和父进程，到底谁先被处理器执行，这个没有固定先后顺序，由操作系统的调度策略来决定。



demo2: 进程间通信-管道方式。（无名管道。有名管道的方式会借助一个明确的带文件名的外部文件去实现。）

![无名管道通信](https://github.com/OneCodeMonkey/OperatingSystem/blob/master/assets/process-communication_message_tunnel_3.png?raw=true)

​					（半双工管道）

demo3: 进程间通信-内核中的消息队列

demo4: 信号量

demo5: 共享内存+信号量控制，加快数据传输速度

###### 对比这几种 IPC 方式的优劣势：

| IPC 方式     | 优劣势                                                       |
| ------------ | ------------------------------------------------------------ |
| 管道通讯     | UNIX 类的系统自带。由于是以文件方式传输，速度较慢。能传递的数据量也有限。并且往往仅用在 fork() 的子进程与父进程之间的通讯。 |
| 内核消息队列 | 通讯方式可以不限于父进程与子进程之间。但消息体的容量受系统限制，且消息队列是独立于进程之外的。在第一次读取时要考虑消息队列是否有上次残留的消息。在PHP中也有消息队列实现共享内存的方式，需要在 php 里开启 `sysvmsg` 扩展 |
| 信号量       | 不用来传递消息体，只是用来进程同步或互斥                     |
| 共享内存区   | 能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存了 |
|              |                                                              |

######  php  也可以用 socket 方式实现 IPC。比如我们的 service 服务，RPC （远程过程调用）的实现方式，就是基于 socket 实现的。
